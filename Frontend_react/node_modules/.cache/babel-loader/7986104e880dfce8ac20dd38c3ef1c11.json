{"ast":null,"code":"import React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\n/**\r\n * @requires useGridColumns (method, event)\r\n * @requires useGridParamsApi (method)\r\n */\n\nexport const useGridColumnSpanning = apiRef => {\n  const lookup = React.useRef({});\n  const setCellColSpanInfo = React.useCallback((rowId, columnIndex, cellColSpanInfo) => {\n    const sizes = lookup.current;\n\n    if (!sizes[rowId]) {\n      sizes[rowId] = {};\n    }\n\n    sizes[rowId][columnIndex] = cellColSpanInfo;\n  }, []);\n  const getCellColSpanInfo = React.useCallback((rowId, columnIndex) => {\n    var _lookup$current$rowId;\n\n    return (_lookup$current$rowId = lookup.current[rowId]) == null ? void 0 : _lookup$current$rowId[columnIndex];\n  }, []); // Calculate `colSpan` for the cell.\n\n  const calculateCellColSpan = React.useCallback(params => {\n    const {\n      columnIndex,\n      rowId,\n      minFirstColumnIndex,\n      maxLastColumnIndex\n    } = params;\n    const visibleColumns = apiRef.current.getVisibleColumns();\n    const columnsLength = visibleColumns.length;\n    const column = visibleColumns[columnIndex];\n    const colSpan = typeof column.colSpan === 'function' ? column.colSpan(apiRef.current.getCellParams(rowId, column.field)) : column.colSpan;\n\n    if (!colSpan || colSpan === 1) {\n      setCellColSpanInfo(rowId, columnIndex, {\n        spannedByColSpan: false,\n        cellProps: {\n          colSpan: 1,\n          width: column.computedWidth\n        }\n      });\n      return {\n        colSpan: 1\n      };\n    }\n\n    let width = column.computedWidth;\n\n    for (let j = 1; j < colSpan; j += 1) {\n      const nextColumnIndex = columnIndex + j; // Cells should be spanned only within their column section (left-pinned, right-pinned and unpinned).\n\n      if (nextColumnIndex >= minFirstColumnIndex && nextColumnIndex < maxLastColumnIndex) {\n        const nextColumn = visibleColumns[nextColumnIndex];\n        width += nextColumn.computedWidth;\n        setCellColSpanInfo(rowId, columnIndex + j, {\n          spannedByColSpan: true,\n          rightVisibleCellIndex: Math.min(columnIndex + colSpan, columnsLength - 1),\n          leftVisibleCellIndex: columnIndex\n        });\n      }\n\n      setCellColSpanInfo(rowId, columnIndex, {\n        spannedByColSpan: false,\n        cellProps: {\n          colSpan,\n          width\n        }\n      });\n    }\n\n    return {\n      colSpan\n    };\n  }, [apiRef, setCellColSpanInfo]); // Calculate `colSpan` for each cell in the row\n\n  const calculateColSpan = React.useCallback(_ref => {\n    let {\n      rowId,\n      minFirstColumn,\n      maxLastColumn\n    } = _ref;\n\n    for (let i = minFirstColumn; i < maxLastColumn; i += 1) {\n      const cellProps = calculateCellColSpan({\n        columnIndex: i,\n        rowId,\n        minFirstColumnIndex: minFirstColumn,\n        maxLastColumnIndex: maxLastColumn\n      });\n\n      if (cellProps.colSpan > 1) {\n        i += cellProps.colSpan - 1;\n      }\n    }\n  }, [calculateCellColSpan]);\n  const columnSpanningApi = {\n    unstable_getCellColSpanInfo: getCellColSpanInfo,\n    unstable_calculateColSpan: calculateColSpan\n  };\n  useGridApiMethod(apiRef, columnSpanningApi, 'GridColumnSpanningAPI');\n  const handleColumnReorderChange = React.useCallback(() => {\n    // `colSpan` needs to be recalculated after column reordering\n    lookup.current = {};\n  }, []);\n  useGridApiEventHandler(apiRef, 'columnOrderChange', handleColumnReorderChange);\n};","map":{"version":3,"sources":["C:/Users/plane/OneDrive/Desktop/git/Frontend/Frontend_react/node_modules/@mui/x-data-grid/hooks/features/columns/useGridColumnSpanning.js"],"names":["React","useGridApiMethod","useGridApiEventHandler","useGridColumnSpanning","apiRef","lookup","useRef","setCellColSpanInfo","useCallback","rowId","columnIndex","cellColSpanInfo","sizes","current","getCellColSpanInfo","_lookup$current$rowId","calculateCellColSpan","params","minFirstColumnIndex","maxLastColumnIndex","visibleColumns","getVisibleColumns","columnsLength","length","column","colSpan","getCellParams","field","spannedByColSpan","cellProps","width","computedWidth","j","nextColumnIndex","nextColumn","rightVisibleCellIndex","Math","min","leftVisibleCellIndex","calculateColSpan","minFirstColumn","maxLastColumn","i","columnSpanningApi","unstable_getCellColSpanInfo","unstable_calculateColSpan","handleColumnReorderChange"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\r\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\r\n\r\n/**\r\n * @requires useGridColumns (method, event)\r\n * @requires useGridParamsApi (method)\r\n */\r\nexport const useGridColumnSpanning = apiRef => {\r\n  const lookup = React.useRef({});\r\n  const setCellColSpanInfo = React.useCallback((rowId, columnIndex, cellColSpanInfo) => {\r\n    const sizes = lookup.current;\r\n\r\n    if (!sizes[rowId]) {\r\n      sizes[rowId] = {};\r\n    }\r\n\r\n    sizes[rowId][columnIndex] = cellColSpanInfo;\r\n  }, []);\r\n  const getCellColSpanInfo = React.useCallback((rowId, columnIndex) => {\r\n    var _lookup$current$rowId;\r\n\r\n    return (_lookup$current$rowId = lookup.current[rowId]) == null ? void 0 : _lookup$current$rowId[columnIndex];\r\n  }, []); // Calculate `colSpan` for the cell.\r\n\r\n  const calculateCellColSpan = React.useCallback(params => {\r\n    const {\r\n      columnIndex,\r\n      rowId,\r\n      minFirstColumnIndex,\r\n      maxLastColumnIndex\r\n    } = params;\r\n    const visibleColumns = apiRef.current.getVisibleColumns();\r\n    const columnsLength = visibleColumns.length;\r\n    const column = visibleColumns[columnIndex];\r\n    const colSpan = typeof column.colSpan === 'function' ? column.colSpan(apiRef.current.getCellParams(rowId, column.field)) : column.colSpan;\r\n\r\n    if (!colSpan || colSpan === 1) {\r\n      setCellColSpanInfo(rowId, columnIndex, {\r\n        spannedByColSpan: false,\r\n        cellProps: {\r\n          colSpan: 1,\r\n          width: column.computedWidth\r\n        }\r\n      });\r\n      return {\r\n        colSpan: 1\r\n      };\r\n    }\r\n\r\n    let width = column.computedWidth;\r\n\r\n    for (let j = 1; j < colSpan; j += 1) {\r\n      const nextColumnIndex = columnIndex + j; // Cells should be spanned only within their column section (left-pinned, right-pinned and unpinned).\r\n\r\n      if (nextColumnIndex >= minFirstColumnIndex && nextColumnIndex < maxLastColumnIndex) {\r\n        const nextColumn = visibleColumns[nextColumnIndex];\r\n        width += nextColumn.computedWidth;\r\n        setCellColSpanInfo(rowId, columnIndex + j, {\r\n          spannedByColSpan: true,\r\n          rightVisibleCellIndex: Math.min(columnIndex + colSpan, columnsLength - 1),\r\n          leftVisibleCellIndex: columnIndex\r\n        });\r\n      }\r\n\r\n      setCellColSpanInfo(rowId, columnIndex, {\r\n        spannedByColSpan: false,\r\n        cellProps: {\r\n          colSpan,\r\n          width\r\n        }\r\n      });\r\n    }\r\n\r\n    return {\r\n      colSpan\r\n    };\r\n  }, [apiRef, setCellColSpanInfo]); // Calculate `colSpan` for each cell in the row\r\n\r\n  const calculateColSpan = React.useCallback(({\r\n    rowId,\r\n    minFirstColumn,\r\n    maxLastColumn\r\n  }) => {\r\n    for (let i = minFirstColumn; i < maxLastColumn; i += 1) {\r\n      const cellProps = calculateCellColSpan({\r\n        columnIndex: i,\r\n        rowId,\r\n        minFirstColumnIndex: minFirstColumn,\r\n        maxLastColumnIndex: maxLastColumn\r\n      });\r\n\r\n      if (cellProps.colSpan > 1) {\r\n        i += cellProps.colSpan - 1;\r\n      }\r\n    }\r\n  }, [calculateCellColSpan]);\r\n  const columnSpanningApi = {\r\n    unstable_getCellColSpanInfo: getCellColSpanInfo,\r\n    unstable_calculateColSpan: calculateColSpan\r\n  };\r\n  useGridApiMethod(apiRef, columnSpanningApi, 'GridColumnSpanningAPI');\r\n  const handleColumnReorderChange = React.useCallback(() => {\r\n    // `colSpan` needs to be recalculated after column reordering\r\n    lookup.current = {};\r\n  }, []);\r\n  useGridApiEventHandler(apiRef, 'columnOrderChange', handleColumnReorderChange);\r\n};"]},"metadata":{},"sourceType":"module"}